<?xml version="1.0" encoding="ASCII"?>
<gep:GeppettoModel
    xmi:version="2.0"
    xmlns:xmi="http://www.omg.org/XMI"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:gep="https://raw.githubusercontent.com/openworm/org.geppetto.model/master/src/main/resources/geppettoModel.ecore"
    xmlns:gep_1="https://raw.githubusercontent.com/openworm/org.geppetto.model/master/src/main/resources/geppettoModel.ecore#//types"
    xmlns:gep_2="https://raw.githubusercontent.com/openworm/org.geppetto.model/master/src/main/resources/geppettoModel.ecore#//datasources">
  <libraries
      id="SWCLibrary"
      name="SWC"/>
  <libraries
      id="OBJLibrary"
      name="OBJ"/>
  <libraries
      id="OWLLibrary"
      name="OWL"/>
  <libraries
      id="ontology"
      name="Ontology">
    <types xsi:type="gep_1:SimpleType"
        id="Individual"
        name="Individual"/>
    <types xsi:type="gep_1:SimpleType"
        id="Class"
        name="Class"/>
    <types xsi:type="gep_1:SimpleType"
        id="Neuron"
        name="Neuron"/>
    <types xsi:type="gep_1:SimpleType"
        id="Neuron_projection_bundle"
        name="Neuron Projection Bundle"/>
    <types xsi:type="gep_1:SimpleType"
        id="Clone"
        name="Clone"/>
    <types xsi:type="gep_1:SimpleType"
        id="Synaptic_neuropil"
        name="Synaptic Neuropil"/>
    <types xsi:type="gep_1:SimpleType"
        id="VFB"
        name="Virtual Fly Brain"/>
    <types xsi:type="gep_1:SimpleType"
        id="Orphan"
        name="No Meta Data"/>
    <types xsi:type="gep_1:SimpleType"
        id="Obsolete"
        name="Obsolete"/>
    <types xsi:type="gep_1:SimpleType"
        id="Synaptic_neuropil_domain"
        name="Synaptic Neuropil Domain"/>
    <types xsi:type="gep_1:SimpleType"
        id="Synaptic_neuropil_subdomain"
        name="Synaptic Neuropil Subdomain"/>
    <types xsi:type="gep_1:SimpleType"
        id="Synaptic_neuropil_block"
        name="Synaptic Neuropil Block"/>
    <types xsi:type="gep_1:SimpleType"
        id="FBDV"
        name="FlyBase Development CV"/>
    <types xsi:type="gep_1:SimpleType"
        id="FBCV"
        name="FlyBase Controlled Vocabulary"/>
    <types xsi:type="gep_1:SimpleType"
        id="FBBI"
        name="FlyBase Biological Imaging Methods"/>
    <types xsi:type="gep_1:SimpleType"
        id="Root"
        name="Top Object"/>
    <types xsi:type="gep_1:SimpleType"
        id="pub"
        name="Publication"/>
    <types xsi:type="gep_1:SimpleType"
        id="Resource"
        name="Resource"/>
    <types xsi:type="gep_1:SimpleType"
        id="VFB_00017894"
        name="JFRC2 template"/>
    <types xsi:type="gep_1:SimpleType"
        id="VFB_00030786"
        name="BrainName standard - Ito half brain"/>
    <types xsi:type="gep_1:SimpleType"
        id="Template"
        name="Template"/>
    <types xsi:type="gep_1:SimpleType"
        id="hasExamples"
        name="Has Examples"/>
    <types xsi:type="gep_1:SimpleType"
        id="Cluster"
        name="Cluster"/>
    <types xsi:type="gep_1:SimpleType"
        id="Ganglion"
        name="Ganglion"/>
    <types xsi:type="gep_1:SimpleType"
        id="DataSet"
        name="Dataset"/>
    <types xsi:type="gep_1:SimpleType"
        id="NBLAST"
        name="NBLAST"/>
    <types xsi:type="gep_1:SimpleType"
        id="Neuromere"
        name="Neuromere"/>
    <types xsi:type="gep_1:SimpleType"
        id="Expression_pattern"
        name="Expression Pattern"/>
    <types xsi:type="gep_1:SimpleType"
        id="Anatomy"
        name="Anatomy"/>
    <types xsi:type="gep_1:SimpleType"
        id="Template"
        name="Template"/>
    <types xsi:type="gep_1:SimpleType"
        id="License"
        name="License"/>
    <types xsi:type="gep_1:SimpleType"
        id="Sensory_neuron"
        name="Sensory Neuron"/>
    <types xsi:type="gep_1:SimpleType"
        id="Peptidergic_neuron"
        name="Peptidergic Neuron"/>
    <types xsi:type="gep_1:SimpleType"
        id="Painted_domain"
        name="Painted Domain"/>
    <types xsi:type="gep_1:SimpleType"
        id="Motor_neuron"
        name="Motor Neuron"/>
    <types xsi:type="gep_1:SimpleType"
        id="Glial_cell"
        name="Glial Cell"/>
    <types xsi:type="gep_1:SimpleType"
        id="Entity"
        name="Entity"/>
    <types xsi:type="gep_1:SimpleType"
        id="Split"
        name="Split"/>
    <types xsi:type="gep_1:SimpleType"
        id="VFB_00101567"
        name="JRC2018U template"/>
    <types xsi:type="gep_1:SimpleType"
        id="VFB_00200000"
        name="JRC2018VU template"/>
    <types xsi:type="gep_1:SimpleType"
        id="NBLASTexp"
        name="NBLAST to exp"/>
    <types xsi:type="gep_1:SimpleType"
        id="has_image"
        name="Has Image"/>
    <types xsi:type="gep_1:SimpleType"
        id="has_neuron_connectivity"
        name="Has Neuron Connectivity"/>
    <types xsi:type="gep_1:SimpleType"
        id="has_region_connectivity"
        name="Has Region Connectivity"/>
    <types xsi:type="gep_1:SimpleType"
        id="NBLASTexp"
        name="NBLAST to exp"/>
    <types xsi:type="gep_1:SimpleType"
        id="neuronbridge"
        name="NeuronBridge"/>
    <types xsi:type="gep_1:SimpleType"
        id="Expression_pattern_fragment"
        name="Expression Pattern Fragment"/>
    <types xsi:type="gep_1:SimpleType"
        id="hasScRNAseq"
        name="has Single Cell RNA Seq Results"/>
    <types xsi:type="gep_1:SimpleType"
        id="Gene"
        name="Gene"/>
  </libraries>
  <libraries
      id="vfbLibrary"
      name="VFB"/>
  <dataSources
      id="neo4JDataSourceService"
      name="neo4j Data Source"
      dataSourceService="neo4jDataSource"
      url="http://pdb.v4.virtualflybrain.org/db/neo4j/tx"
      dependenciesLibrary="//@libraries.3"
      targetLibrary="//@libraries.4">
    <libraryConfigurations
        library="//@libraries.0"
        modelInterpreterId="swcModelInterpreterService"
        format="swc"/>
    <libraryConfigurations
        library="//@libraries.1"
        modelInterpreterId="objModelInterpreterService"
        format="obj"/>
    <libraryConfigurations
        library="//@libraries.2"
        modelInterpreterId="owlModelInterpreterService"
        format="owl"/>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Get and process example images from Neo4j for class list"
        description=""
        runForCount="false">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="anatomy_query"
          description="fetch Individual instances from Class ID list"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Class) WHERE primary.short_form in $ids WITH primary CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.symbol[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,primary RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'bac066c' AS version, 'anatomy_query' AS query, anatomy_channel_image&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS }"
          countQuery="&quot;statement&quot;: &quot;MATCH (n:Class) WHERE n.short_form IN $ids RETURN count(n) AS count&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process images"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Get and process details from Neo4j for list of inds"
        description=""
        runForCount="false">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="GetMetaForIndList"
          name="anat_image_query"
          description="Get images for individual list"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Individual) WHERE primary.short_form in $ids WITH primary OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary OPTIONAL MATCH (primary)-[:INSTANCEOF]->(typ:Class) WITH CASE WHEN typ is null THEN [] ELSE collect ({ short_form: typ.short_form, label: coalesce(typ.label,''), iri: typ.iri, types: labels(typ), symbol: coalesce(typ.symbol[0], '')} ) END AS types,primary,channel_image RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'bac066c' AS version, 'anat_image_query' AS query, channel_image, types &quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"
          countQuery="&quot;statement&quot;: &quot;MATCH(i:Individual) WHERE i.short_form IN $ids RETURN count(i) as count&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          runForCount="false"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Get fellow cluster members"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="GetFellowClusterMembers"
          name="Get other cluster members"
          description="$NAME's fellow cluster members"
          query="&quot;statement&quot;: &quot;MATCH (n:Neuron { short_form: $id } )-[r1:member_of]->(c:Cluster)-[r2:has_member]->(i:Neuron)&lt;-[:depicts]-(j:Individual)-[k:in_register_with]->(m:Individual) OPTIONAL MATCH (i)-[:INSTANCEOF]->(ec:Class) RETURN DISTINCT i.short_form as id, CASE WHEN not i.synonym is null THEN i.label+replace(' ('+reduce(a='',n in i.synonym|a+n+', ')+')',', )',')') ELSE i.label END as name, i.description[0] as def, COLLECT(DISTINCT ec.label) as type, COLLECT(DISTINCT replace(k.folder[0],'http:','https:') + '/thumbnailT.png') as file&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (n:Neuron { short_form: $id } )-[r1:member_of]->(c:Cluster)-[r2:has_member]->(i:Neuron) RETURN count(i) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="vfbCreateResultListForIndividualsForQueryResultsQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="All example images for a class"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Fetch all example individuals for Class"
          description="Fetch all example Individual instances of this Class or subclasses"
          returnType="//@libraries.3/@types.0"
          query="&quot;statement&quot;: &quot;MATCH (c:Class)&lt;-[:INSTANCEOF|SUBCLASSOF*..]-(primary:Individual)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WHERE c.short_form in [$id] WITH template, channel, template_anat, irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary OPTIONAL MATCH (primary)-[:INSTANCEOF]->(typ:Class) WITH CASE WHEN typ is null THEN [] ELSE collect ({ short_form: typ.short_form, label: coalesce(typ.label,''), iri: typ.iri, types: labels(typ), symbol: coalesce(typ.symbol[0], '')} ) END AS types,primary,channel_image RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'm20210224' AS version, 'EXAMPLES_anat_image_query' AS query, channel_image, types&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (c:Class)&lt;-[:INSTANCEOF|SUBCLASSOF*..]-(n:Individual)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WHERE c.short_form in [$id] RETURN count(n) AS count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="domainsForTempId"
        name="Find domains for template"
        description="Doamins for template"
        returnType="//@libraries.3/@types.0">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="domainsForTempQuery"
          name="Find domain individuals for template id"
          description="Find domain individuals for template id"
          returnType="//@libraries.3/@types.0"
          query="&quot;statement&quot;: &quot;MATCH (n:Template {short_form:$id})&lt;-[:depicts]-(:Template)&lt;-[r:in_register_with]-(dc:Individual)-[:depicts]->(di:Individual)-[:INSTANCEOF]->(d:Class) WHERE exists(r.index) RETURN distinct di.short_form as id, di.label as name, coalesce(di.description[0],d.description[0]) as def, COLLECT(DISTINCT d.label) as type, replace(r.folder[0],'http:','https:') + '/thumbnailT.png' as file&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (n:Template {short_form:$id})&lt;-[:depicts]-(:Template)&lt;-[r:in_register_with]-(dc:Individual)-[:depicts]->(di:Individual)-[:INSTANCEOF]->(d:Class) WHERE exists(r.index) RETURN count(di) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="vfbCreateResultListForIndividualsForQueryResultsQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Get cluster members"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="GetClusterMembers"
          name="Get cluster members"
          description="$NAME's members"
          query="&quot;statement&quot;: &quot;MATCH (c:Cluster { short_form: $id } )-[r2:has_member]->(i:Neuron)&lt;-[:depicts]-(j:Individual)-[k:in_register_with]->(m:Individual) OPTIONAL MATCH (i)-[:INSTANCEOF]->(ec:Class) RETURN DISTINCT i.short_form as id, CASE WHEN not i.synonym is null THEN i.label+replace(' ('+reduce(a='',n in i.synonym|a+n+', ')+')',', )',')') ELSE i.label END as name, i.description[0] as def, COLLECT(DISTINCT ec.label) as type, COLLECT(DISTINCT replace(k.folder[0],'http:','https:') + '/thumbnailT.png') as file&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (c:Cluster { short_form: $id } )-[r2:has_member]->(i:Neuron) RETURN count(i) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="vfbCreateResultListForIndividualsForQueryResultsQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="imagesForDataSet"
        name="Find images for dataset"
        description="Images in a dataset"
        returnType="//@libraries.3/@types.0">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="neoImagesForDataSet"
          name="Find images for dataset"
          description="Find images for a dataset"
          returnType="//@libraries.3/@types.0"
          query="&quot;statement&quot;: &quot;MATCH (c:DataSet)&lt;-[:has_source]-(primary:Individual)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WHERE c.short_form in [$id] WITH template, channel, template_anat, irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary OPTIONAL MATCH (primary)-[:INSTANCEOF]->(typ:Class) WITH CASE WHEN typ is null THEN [] ELSE collect ({ short_form: typ.short_form, label: coalesce(typ.label,''), iri: typ.iri, types: labels(typ), symbol: coalesce(typ.symbol[0], '')} ) END AS types,primary,channel_image RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'm20210224' AS version, 'EXAMPLES_anat_image_query' AS query, channel_image, types&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (c:DataSet)&lt;-[:has_source]-(primary:Individual)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WHERE c.short_form in [$id] RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="imagesForTempId"
        name="Find images aligned to a template"
        description="Aligned images for template"
        returnType="//@libraries.3/@types.0">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="imagesForTempQuery"
          name="Find images aligned to template id"
          description="Find images aligned to template id"
          returnType="//@libraries.3/@types.0"
          query="&quot;statement&quot;: &quot;MATCH (n:Template {short_form:$id})&lt;-[:depicts]-(:Template)&lt;-[r:in_register_with]-(dc:Individual)-[:depicts]->(di:Individual) OPTIONAL MATCH (di)-[:INSTANCEOF]->(d:Class) RETURN distinct di.short_form as id, di.label as name, coalesce(di.description[0],d.description[0]) as def, COLLECT(DISTINCT d.label) as type, replace(r.folder[0],'http:','https:') + '/thumbnailT.png' as file&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (n:Template {short_form:$id})&lt;-[:depicts]-(:Template)&lt;-[r:in_register_with]-(dc:Individual)-[:depicts]->(di:Individual) RETURN count(di) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="vfbCreateResultListForIndividualsForQueryResultsQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Query for exp from anatomy with no warning"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Test Query for Exp from Anatomy"
          description="Get JSON for anat_2_ep query"
          returnType="//@libraries.3/@types.1"
          query="&quot;statement&quot;: &quot;MATCH (ep:Class:Expression_pattern)&lt;-[ar:overlaps|part_of]-(:Individual)-[:INSTANCEOF]->(anat:Class) WHERE anat.short_form in $ids WITH DISTINCT collect(DISTINCT ar.pub) as pubs, anat, ep UNWIND pubs as p MATCH (pub:pub { short_form: p}) WITH anat, ep, collect({ core: { short_form: pub.short_form, label: coalesce(pub.label,''), iri: pub.iri, types: labels(pub), symbol: coalesce(pub.`symbol`[0], '')} , PubMed: coalesce(pub.PMID[0], ''), FlyBase: coalesce(pub.FlyBase[0], ''), DOI: coalesce(pub.DOI[0], '') }) as pubs CALL apoc.cypher.run('WITH ep OPTIONAL MATCH (ep)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {ep:ep}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, anat, ep, pubs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class)  WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,anat,ep,pubs RETURN { short_form: anat.short_form, label: coalesce(anat.label,''), iri: anat.iri, types: labels(anat), symbol: coalesce(anat.`symbol`[0], '')}  as anatomy, { short_form: ep.short_form, label: coalesce(ep.label,''), iri: ep.iri, types: labels(ep), symbol: coalesce(ep.`symbol`[0], '')}  AS expression_pattern, 'Get JSON for anat_2_ep query' AS query, 'de64597' AS version , pubs, anatomy_channel_image&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"
          countQuery="&quot;statement&quot;: &quot;MATCH (anat:Class) WHERE anat.short_form IN $ids OPTIONAL MATCH (ep:Class)&lt;-[ar:overlaps|part_of]-(:Individual)-[:INSTANCEOF]->(anat) RETURN count(ep) as count&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          returnType="//@libraries.3/@types.1"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Test Query for anatomy from expression"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Query for Anatomy from Exp"
          description="Get JSON for ep_2_anat query"
          returnType="//@libraries.3/@types.1"
          query="&quot;statement&quot;: &quot;MATCH (ep:Expression_pattern:Class)&lt;-[ar:overlaps|part_of]-(anoni:Individual)-[:INSTANCEOF]->(anat:Class) WHERE ep.short_form in $ids WITH anoni, anat, ar OPTIONAL MATCH (p:pub { short_form: ar.pub}) WITH anat, anoni, { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.symbol[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } AS pub OPTIONAL MATCH (anoni)-[r:Related]->(o:FBdv) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets,[])), symbol: coalesce(o.symbol[0], '')} }) END AS stages ,anoni,anat,pub CALL apoc.cypher.run('WITH anat OPTIONAL MATCH (anat)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {anat:anat}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, anoni, anat, pub, stages OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.symbol[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,anoni,anat,pub,stages RETURN { short_form: anat.short_form, label: coalesce(anat.label,''), iri: anat.iri, types: labels(anat), symbol: coalesce(anat.symbol[0], '')} AS anatomy, 'Get JSON for ep_2_anat query' AS query, 'bac066c' AS version , pub, stages, anatomy_channel_image&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"
          countQuery="&quot;statement&quot;: &quot;MATCH (ep:Expression_pattern:Class)&lt;-[ar:overlaps|part_of]-(anoni:Individual)-[:INSTANCEOF]->(anat:Class) WHERE ep.short_form in $ids RETURN count(anat) as count&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          returnType="//@libraries.3/@types.1"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Query for anatomy from expression "
        description="Get JSON for anat_2_ep query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="ep_2_anat_query"
          name="Test Query for Anatomy from Exp"
          description="Get JSON for ep_2_anat query"
          returnType="//@libraries.3/@types.1"
          query="&quot;statement&quot;: &quot;MATCH (ep:Expression_pattern:Class)&lt;-[ar:overlaps|part_of]-(anoni:Individual)-[:INSTANCEOF]->(anat:Class) WHERE ep.short_form in [$id] WITH  anoni, anat, ar OPTIONAL MATCH (p:pub { short_form: ar.pub}) WITH anat, anoni, { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } AS pub OPTIONAL MATCH (anoni)-[r:Related]->(o:FBdv) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets,[])), symbol: coalesce(o.`symbol`[0], '')}  }) END AS stages ,anoni,anat,pub CALL apoc.cypher.run('WITH anat OPTIONAL MATCH (anat)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {anat:anat}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, anoni, anat, pub, stages OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,anoni,anat,pub,stages RETURN { short_form: anat.short_form, label: coalesce(anat.label,''), iri: anat.iri, types: labels(anat), symbol: coalesce(anat.`symbol`[0], '')}  AS anatomy, 'Get JSON for ep_2_anat query' AS query, '3f881fe' AS version , pub, stages, anatomy_channel_image&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot;}"
          countQuery="&quot;statement&quot;: &quot;MATCH (ep:Class:Expression_pattern)&lt;-[ar:overlaps|part_of]-(anoni:Individual)-[:INSTANCEOF]->(anat:Class) WHERE ep.short_form in [$id] RETURN count(anat) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot;}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          returnType="//@libraries.3/@types.1"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Test Query for exp from anatomy without warning 2"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Query for Exp from Anatomy"
          description="Get JSON for anat_2_ep query"
          returnType="//@libraries.3/@types.1"
          query="&quot;statement&quot;: &quot;MATCH (ep:Class:Expression_pattern)&lt;-[ar:overlaps|part_of]-(:Individual)-[:INSTANCEOF]->(anat:Class) WHERE anat.short_form in $ids WITH DISTINCT collect(DISTINCT ar.pub) as pubs, anat, ep UNWIND pubs as p MATCH (pub:pub { short_form: p}) WITH anat, ep, collect({ core: { short_form: pub.short_form, label: coalesce(pub.label,''), iri: pub.iri, types: labels(pub), symbol: coalesce(pub.`symbol`[0], '')} , PubMed: coalesce(pub.PMID[0], ''), FlyBase: coalesce(pub.FlyBase[0], ''), DOI: coalesce(pub.DOI[0], '') }) as pubs CALL apoc.cypher.run('WITH ep OPTIONAL MATCH (ep)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {ep:ep}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, anat, ep, pubs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class)  WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,anat,ep,pubs RETURN { short_form: anat.short_form, label: coalesce(anat.label,''), iri: anat.iri, types: labels(anat), symbol: coalesce(anat.`symbol`[0], '')}  as anatomy, { short_form: ep.short_form, label: coalesce(ep.label,''), iri: ep.iri, types: labels(ep), symbol: coalesce(ep.`symbol`[0], '')}  AS expression_pattern, 'Get JSON for anat_2_ep query' AS query, 'de64597' AS version , pubs, anatomy_channel_image&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"
          countQuery="&quot;statement&quot;: &quot;MATCH (anat:Class) WHERE anat.short_form IN $ids OPTIONAL MATCH (ep:Class)&lt;-[ar:overlaps|part_of]-(:Individual)-[:INSTANCEOF]->(anat) RETURN count(ep) as count&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          returnType="//@libraries.3/@types.1"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Datasets available for Template"
        description="Get JSON for template_2_datasets query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="template_2_datasets_query"
          description="Get JSON for template_2_datasets query"
          returnType="//@libraries.3/@types.24"
          query="&quot;statement&quot;: &quot;MATCH (t:Template) &lt;-[depicts]-(tc:Template)-[:in_register_with]-(c:Individual)-[:depicts]->(ai:Individual)-[:has_source]->(ds:DataSet) WHERE t.short_form in [$id] WITH distinct ds, t CALL apoc.cypher.run('WITH ds, template_anat OPTIONAL MATCH (ds) &lt;- [:has_source]-(i:Individual) &lt;-[:depicts]- (channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat) RETURN template, channel, template_anat, i, irw limit 5', {ds:ds, template_anat:t}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, ds OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.symbol[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,ds OPTIONAL MATCH (ds)-[rp:has_reference]->(p:pub) WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.symbol[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } ) END AS pubs,ds,anatomy_channel_image OPTIONAL MATCH (ds)-[:has_license|license]->(l:License) WITH collect ({ icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets,[])), symbol: coalesce(l.symbol[0], '')} }) as license,ds,anatomy_channel_image,pubs OPTIONAL MATCH (ds) &lt;-[:has_source]-(i:Individual) WITH i, ds, anatomy_channel_image, pubs, license OPTIONAL MATCH (i)-[:INSTANCEOF]-(c:Class) WITH DISTINCT { images: count(distinct i),types: count(distinct c) } as dataset_counts,ds,anatomy_channel_image,pubs,license RETURN { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), symbol: coalesce(ds.symbol[0], '')} as dataset, 'bac066c' AS version, 'template_2_datasets_query' AS query, anatomy_channel_image, pubs, license, dataset_counts&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (t:Template)&lt;-[depicts]-(tc:Template)-[:in_register_with]-(c:Individual)-[:depicts]->(ai:Individual)-[:has_source]->(ds:DataSet) WHERE t.short_form in [$id] WITH distinct ds RETURN count(ds) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          returnType="//@libraries.3/@types.1"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Datasaets available"
        description="Get JSON for template_2_datasets query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="test_all_datasets_query"
          description="Get JSON for template_2_datasets query"
          returnType="//@libraries.3/@types.24"
          query="&quot;statement&quot;: &quot;MATCH (t:Template)&lt;-[depicts]-(tc:Template)-[:in_register_with]-(c:Individual)-[:depicts]->(ai:Individual)-[:has_source]->(ds:DataSet) WITH distinct ds CALL apoc.cypher.run('WITH ds OPTIONAL MATCH (ds) &lt;-[:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual) &lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {ds:ds}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, ds OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.symbol[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,ds OPTIONAL MATCH (ds)-[rp:has_reference]->(p:pub) WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.symbol[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } ) END AS pubs,ds,anatomy_channel_image OPTIONAL MATCH (ds)-[:has_license|license]->(l:License) WITH collect ({ icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets,[])), symbol: coalesce(l.symbol[0], '')} }) as license,ds,anatomy_channel_image,pubs OPTIONAL MATCH (ds) &lt;-[:has_source]-(i:Individual) WITH i, ds, anatomy_channel_image, pubs, license OPTIONAL MATCH (i)-[:INSTANCEOF]-(c:Class) WITH DISTINCT { images: count(distinct i),types: count(distinct c) } as dataset_counts,ds,anatomy_channel_image,pubs,license RETURN { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), symbol: coalesce(ds.symbol[0], '')} as dataset, 'bac066c' AS version, 'all_datasets_query' AS query, anatomy_channel_image, pubs, license, dataset_counts&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (ds:DataSet) WITH distinct ds RETURN count(ds) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          returnType="//@libraries.3/@types.1"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Test Query for exp from anatomy without warning 3"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Query for Exp from Anatomy"
          description="Get JSON for anat_2_ep query"
          returnType="//@libraries.3/@types.1"
          query="&quot;statement&quot;: &quot;MATCH (ep:Class:Expression_pattern)&lt;-[ar:overlaps|part_of]-(:Individual)-[:INSTANCEOF]->(anat:Class) WHERE anat.short_form in $ids WITH DISTINCT collect(DISTINCT ar.pub) as pubs, anat, ep UNWIND pubs as p MATCH (pub:pub { short_form: p}) WITH anat, ep, collect({ core: { short_form: pub.short_form, label: coalesce(pub.label,''), iri: pub.iri, types: labels(pub), symbol: coalesce(pub.`symbol`[0], '')} , PubMed: coalesce(pub.PMID[0], ''), FlyBase: coalesce(pub.FlyBase[0], ''), DOI: coalesce(pub.DOI[0], '') }) as pubs CALL apoc.cypher.run('WITH ep OPTIONAL MATCH (ep)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {ep:ep}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, anat, ep, pubs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class)  WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,anat,ep,pubs RETURN { short_form: anat.short_form, label: coalesce(anat.label,''), iri: anat.iri, types: labels(anat), symbol: coalesce(anat.`symbol`[0], '')}  as anatomy, { short_form: ep.short_form, label: coalesce(ep.label,''), iri: ep.iri, types: labels(ep), symbol: coalesce(ep.`symbol`[0], '')}  AS expression_pattern, 'Get JSON for anat_2_ep query' AS query, 'de64597' AS version , pubs, anatomy_channel_image&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"
          countQuery="&quot;statement&quot;: &quot;MATCH (anat:Class) WHERE anat.short_form IN $ids OPTIONAL MATCH (ep:Class)&lt;-[ar:overlaps|part_of]-(:Individual)-[:INSTANCEOF]->(anat) RETURN count(ep) as count&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          returnType="//@libraries.3/@types.1"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="compound_neuron_region_connectivity_query"
        name="neuron_region_connectivity_query"
        description="compound query for neo4j neuron_region_connectivity_query ">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="neuron_region_connectivity_query"
          name="neuron_region_connectivity_query"
          description="neuron_region_connectivity_query"
          query="&quot;statement&quot;: &quot;MATCH (primary) WHERE primary.short_form in [$id] WITH primary MATCH (target:Individual)&lt;-[r:has_presynaptic_terminals_in|has_postsynaptic_terminal_in]-(primary) WITH DISTINCT collect(properties(r)) + {} as props, target, primary WITH apoc.map.removeKeys(apoc.map.merge(props[0], props[1]),['iri', 'short_form', 'Related', 'label', 'type']) as synapse_counts, { short_form: target.short_form, label: coalesce(target.label,''), iri: target.iri, types: labels(target), symbol: coalesce(target.`symbol`[0], '')} as object, target,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(target) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets,[])), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary,target,synapse_counts, object OPTIONAL MATCH (target)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, target, synapse_counts, object, parents   OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary,target,synapse_counts, object,parents RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, '64731dc' AS version , synapse_counts, object, parents, channel_image, 'neuron_region_connectivity_query' as query&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary) WHERE primary.short_form in [$id] WITH primary MATCH (target:Individual)&lt;-[r:has_presynaptic_terminals_in|has_postsynaptic_terminal_in]-(primary) RETURN count(target) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="compound_neuron_neuron_connectivity_query"
        name="neuron_neuron_connectivity_query"
        description="compound query for neo4j neuron_neuron_connectivity_query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="neuron_neuron_connectivity_query"
          name="neuron_neuron_connectivity_query"
          description="neuron_neuron_connectivity_query"
          query="&quot;statement&quot;: &quot;MATCH (primary) WHERE primary.short_form in [$id] WITH primary MATCH (oi:Individual)-[r:synapsed_to]-(primary:Individual) WHERE exists(r.weight) AND r.weight[0] > 1 WITH primary, oi OPTIONAL MATCH (oi)&lt;-[down:synapsed_to]-(primary) WITH down, oi, primary OPTIONAL MATCH (primary)&lt;-[up:synapsed_to]-(oi) WITH { downstream: [coalesce(down.weight[0],0)], upstream:[coalesce(up.weight[0],0)] } as synapse_counts, { short_form: oi.short_form, label: coalesce(oi.label,''), iri: oi.iri, types: labels(oi), symbol: coalesce(oi.`symbol`[0], '')}  as object, oi,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(oi) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets,[])), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary,oi,synapse_counts, object OPTIONAL MATCH (oi)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, oi, synapse_counts, object, parents   OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary,oi,synapse_counts, object,parents RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, '64731dc' AS version , synapse_counts, object, parents, channel_image, 'neuron_neuron_connectivity_query' as query&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary) WHERE primary.short_form in [$id] WITH primary MATCH (oi:Individual)-[r:synapsed_to]-(primary:Individual) WHERE exists(r.weight) AND r.weight[0] > 1 RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="vfb_query schema processor"
          description="vfb_query schema processor"
          runForCount="false"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="has_similar_morphology_to"
        name="NBLAST similarity neo Query"
        description="NBLAST similarity neo Query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="NBLAST_anat_image_query"
          name="NBLAST_anat_image_query"
          description="find has_similar_morphology_to relationships"
          query="&quot;statement&quot;: &quot;MATCH (n:Individual)-[nblast:has_similar_morphology_to]-(primary:Individual) WHERE n.short_form in [$id] AND exists(nblast.NBLAST_score) WITH primary, nblast OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, nblast OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary, nblast OPTIONAL MATCH (primary)-[:INSTANCEOF]->(typ:Class) WITH CASE WHEN typ is null THEN [] ELSE collect ({ short_form: typ.short_form, label: coalesce(typ.label,''), iri: typ.iri, types: labels(typ), symbol: coalesce(typ.symbol[0], '')} ) END AS types,primary,channel_image, nblast RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, nblast.NBLAST_score[0] as score, 'm20210225' AS version, 'NBLAST_anat_image_query' AS query, channel_image, types&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (n:Individual)-[nblast:has_similar_morphology_to]-(primary:Individual) WHERE n.short_form in [$id] AND exists(nblast.NBLAST_score) RETURN count(primary) AS count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="Process Images"
          description="vfb_query_schema_processor"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="All referenced Entities from a pub"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Fetch all entities for pub"
          description="Fetch all entities that have reference to pub"
          returnType="//@libraries.3/@types.0"
          query="&quot;statement&quot;: &quot;MATCH (p:pub)&lt;-[:has_reference]-(primary) WHERE p.short_form in [$id] WITH distinct primary CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;-[:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual) WHERE primary:Class WITH coalesce(i,primary) as i OPTIONAL MATCH (i)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]-> (template_anat:Individual)  RETURN template, channel, template_anat, i, irw limit 5', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.symbol[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,primary RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'm_bac066c' AS version, 'pub_from_anatomy_query' AS query, anatomy_channel_image&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (p:pub)&lt;-[:has_reference]-(primary) WHERE p.short_form in [$id] WITH distinct primary RETURN count(primary) AS count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="has_similar_morphology_to_part_of"
        name="NBLASTexp similarity neo Query"
        description="NBLASTexp similarity neo Query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="NBLAST_anat_image_query_exp"
          name="NBLAST_anat_image_query_exp"
          description="find has_similar_morphology_to relationships"
          query="&quot;statement&quot;: &quot;MATCH (n:Individual)-[nblast:has_similar_morphology_to_part_of]-(primary:Individual) WHERE n.short_form in [$id] AND EXISTS(nblast.NBLAST_score) WITH primary, nblast OPTIONAL MATCH (c:Class)&lt;-[:INSTANCEOF]-(primary) OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, nblast OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary, nblast OPTIONAL MATCH (primary)-[:INSTANCEOF]->(typ:Class) WITH CASE WHEN typ is null THEN [] ELSE collect ({ short_form: typ.short_form, label: coalesce(typ.label,''), iri: typ.iri, types: labels(typ), symbol: coalesce(typ.symbol[0], '')} ) END AS types,primary,channel_image, nblast RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, nblast.NBLAST_score[0] as score, 'm20220726' AS version, 'NBLASTexp_anat_image_query' AS query, channel_image, types&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (n:Individual)-[nblast:has_similar_morphology_to_part_of]-(primary:Individual) WHERE n.short_form in [$id] AND EXISTS(nblast.NBLAST_score) RETURN count(primary) AS count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="Process Images NBLASTexp"
          description="vfb_query_schema_processor"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="has_similar_morphology_to_nb"
        name="NeuronBridge similarity neo Query"
        description="NeuronBridge similarity neo Query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="NB_anat_image_query"
          name="NB_anat_image_query"
          description="find has_similar_morphology_to relationships"
          query="&quot;statement&quot;: &quot;MATCH (n:Individual)-[nblast:has_similar_morphology_to_part_of]-(primary:Individual) WHERE n.short_form in [$id] AND exists(nblast.neuronbridge_score)  WITH primary, nblast OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, nblast OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets,[])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets,[])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets,[])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary, nblast OPTIONAL MATCH (primary)-[:INSTANCEOF]->(typ:Class) WITH CASE WHEN typ is null THEN [] ELSE collect ({ short_form: typ.short_form, label: coalesce(typ.label,''), iri: typ.iri, types: labels(typ), symbol: coalesce(typ.symbol[0], '')} ) END AS types,primary,channel_image, nblast RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])), symbol: coalesce(primary.symbol[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, nblast.neuronbridge_score[0] as score, 'm20220726' AS version, 'NeuronBridge_anat_image_query' AS query, channel_image, types&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (n:Individual)-[nblast:has_similar_morphology_to_part_of]-(primary:Individual) WHERE n.short_form in [$id] AND exists(nblast.neuronbridge_score) RETURN count(primary) AS count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="Process Images NB"
          description="vfb_query_schema_processor"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="cluster_expression_query_compound"
        name="cluster_expression_query"
        description="Get JSON for cluster expression query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="cluster_expression_query"
          name="Get JSON for cluster expression query"
          description="Get JSON for cluster expression query"
          query="&quot;statement&quot;: &quot;MATCH (primary:Individual:Cluster) WHERE primary.short_form in [$id] WITH primary MATCH (primary)-[e:expresses]->(g:Gene:Class) WITH coalesce(e.expression_level_padded[0], e.expression_level[0]) as expression_level, e.expression_extent[0] as expression_extent, { short_form: g.short_form, label: coalesce(g.label,''), iri: g.iri, types: labels(g), unique_facets: apoc.coll.sort(coalesce(g.uniqueFacets, [])), symbol: coalesce(([]+g.symbol)[0], '')}  AS gene,primary MATCH (a:Anatomy)&lt;-[:composed_primarily_of]-(primary) WITH { short_form: a.short_form, label: coalesce(a.label,''), iri: a.iri, types: labels(a), unique_facets: apoc.coll.sort(coalesce(a.uniqueFacets, [])), symbol: coalesce(([]+a.symbol)[0], '')}  AS anatomy,primary,expression_level,expression_extent,gene  RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for cluster expression query' AS query, 'a3c0d68' AS version , expression_level, expression_extent, gene, anatomy&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Individual:Cluster) WHERE primary.short_form in [$id] WITH primary MATCH (primary)-[e:expresses]->(g:Gene:Class) RETURN count(g) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="Process genes"
          description="vfb_query_schema_processor"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="anat_scRNAseq_query_compound"
        name="anat_scRNAseq_query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for anat scRNAseq query"
          description="Get JSON for anat scRNAseq query"
          query="&quot;statement&quot;: &quot;MATCH (primary:Class:Anatomy) WHERE primary.short_form in $ids OR primary.short_form = $id WITH primary MATCH (primary)&lt;-[:composed_primarily_of]-(c:Cluster)-[:has_source]->(ds:scRNAseq_DataSet)OPTIONAL MATCH (ds)-[:has_reference]->(p:pub) WITH { short_form: c.short_form, label: coalesce(c.label,''), iri: c.iri, types: labels(c), unique_facets: apoc.coll.sort(coalesce(c.uniqueFacets, [])), symbol: coalesce(([]+c.symbol)[0], '')}  AS cluster, { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')}  AS dataset, COLLECT({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') }) AS pubs,primary RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for anat scRNAseq query' AS query, 'a3c0d68' AS version , cluster, dataset, pubs&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS , &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Class:Anatomy) WHERE primary.short_form in $ids OR primary.short_form = $id WITH primary MATCH (primary)&lt;-[:composed_primarily_of]-(c:Cluster)-[:has_source]->(ds:scRNAseq_DataSet) RETURN count(c) as count&quot;, &quot;parameters&quot; : { &quot;ids&quot; : $ARRAY_ID_RESULTS , &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="dataset_scRNAseq_query_compound"
        name="dataset_scRNAseq_query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for dataset scRNAseq query"
          description="Get JSON for dataset scRNAseq query"
          query="&quot;statement&quot;: &quot;MATCH (c:Individual)-[:has_source]->(ds:scRNAseq_DataSet) WHERE ds.short_form = $id OPTIONAL MATCH (ds)-[:has_reference]->(p:pub) WITH COLLECT({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') }) AS pubs, c RETURN { core : { short_form: c.short_form, label: coalesce(c.label,''), iri: c.iri, types: labels(c), unique_facets: apoc.coll.sort(coalesce(c.uniqueFacets, [])), symbol: coalesce(([]+c.symbol)[0], '')} , description : coalesce(c.description, []), comment : coalesce(c.comment, []) } AS term, 'Get JSON for dataset scRNAseq query' AS query, 'ma3c0d68' AS version, pubs&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (c:Individual)-[:has_source]->(ds:scRNAseq_DataSet) WHERE ds.short_form = $id RETURN count(c) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Images"
          returnType="//@libraries.3/@types.0"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <queries
        xsi:type="gep_2:CompoundQuery"
        id="expression_cluster_query_compound"
        name="expression_cluster_query"
        description="Get JSON for expression in cluster query">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          id="cluster_expression_query"
          name="Get JSON for cluster expression query"
          description="Get JSON for cluster expression query"
          query="&quot;statement&quot;: &quot;MATCH (primary:Individual:Cluster)-[e:expresses]->(g:Gene:Class) WHERE g.short_form in [$id] WITH e.expression_level[0] as expression_level, e.expression_extent[0] as expression_extent, { short_form: g.short_form, label: coalesce(g.label,''), iri: g.iri, types: labels(g), unique_facets: apoc.coll.sort(coalesce(g.uniqueFacets, [])), symbol: coalesce(([]+g.symbol)[0], '')}  AS gene,primary MATCH (a:Anatomy)&lt;-[:composed_primarily_of]-(primary) WITH { short_form: a.short_form, label: coalesce(a.label,''), iri: a.iri, types: labels(a), unique_facets: apoc.coll.sort(coalesce(a.uniqueFacets, [])), symbol: coalesce(([]+a.symbol)[0], '')}  AS anatomy,primary,expression_level,expression_extent,gene  RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for expression in cluster query' AS query, 'ma3c0d68' AS version , expression_level, expression_extent, anatomy&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Individual:Cluster)-[e:expresses]->(g:Gene:Class) WHERE g.short_form in [$id] RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          id="vfb_query_schema_processor"
          name="Process clusters"
          description="vfb_query_schema_processor"
          queryProcessorId="neo4jQueryProcessor"/>
    </queries>
    <fetchVariableQuery
        xsi:type="gep_2:CompoundQuery"
        name="Compound query for collating term information"
        description="Compound query for collating term information">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get term core info"
          description="Fetches term core details."
          query="&quot;statement&quot;: &quot;MATCH (primary:Entity {short_form: $id}) RETURN { core: { short_form: primary.short_form, label: primary.label, iri: primary.iri, types: labels(primary) }} as term&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Entity {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Term Core"
          description="Process Term Core"
          queryProcessorId="vfbProcessTermInfoCore"/>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get baseline term info"
          description="Fetches basic term details."
          query="&quot;statement&quot;: &quot;MATCH (primary {short_form: $id }) WHERE NOT primary:pub AND NOT primary:License AND NOT primary:Individual AND NOT primary:Class AND NOT primary:Template AND NOT primary:DataSet OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary)  WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: o.label, iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets,[])) } ) END AS parents , primary OPTIONAL MATCH (o:Class)&lt;-[r { type: 'Related' }]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.uri, type: type(r) } , object: { short_form: o.short_form, label: o.label, iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets,[])) }  }) END AS relationships , parents, primary OPTIONAL MATCH (s:Site)&lt;-[dbx:hasDbXref]-(primary)  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link: s.link_base + coalesce(dbx.accession, ''), link_text: s.label, site: { short_form: s.short_form, label: s.label, iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets,[])) }, icon: coalesce(s.link_icon_url[0], '') }) END AS xrefs, parents, relationships, primary OPTIONAL MATCH (primary)-[rp:has_reference { typ: 'syn'}]->(p:pub:Individual)  WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: p.label, iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets,[])) } , PubMed: coalesce(p.PMID, ''), FlyBase: coalesce(p.FlyBase, ''), DOI: coalesce(p.DOI, '') } , synonym: { label: coalesce(rp.synonym[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(rp.cat,'') }  }) END AS pub_syn, parents, relationships, xrefs, primary OPTIONAL MATCH (primary)-[rp:has_reference { typ: 'def'}]->(p:pub:Individual) WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: p.label, iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets,[])) } , PubMed: coalesce(p.PMID, ''), FlyBase: coalesce(p.FlyBase, ''), DOI: coalesce(p.DOI, '') } ) END AS def_pubs, parents, relationships, xrefs, pub_syn, primary RETURN { core: { short_form: primary.short_form, label: primary.label, iri: primary.iri, types: labels(primary),  unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets,[])) } , description: coalesce(primary.description, []), comment: coalesce(primary.`annotation-comment`, [])} as term ,parents,relationships,xrefs,pub_syn,def_pubs, 'Base' as query, 'manual' AS version&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"/>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for Class"
          description="Get JSON for Class"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Class) WHERE primary.short_form in [$id] WITH primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Class' AS query, '89ca20c' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Class {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.1"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for Neuron Class"
          description="Get JSON for Neuron Class"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Class) WHERE primary.short_form in [$id] WITH primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn OPTIONAL MATCH (:Class { label: 'intersectional expression pattern'})&lt;-[:SUBCLASSOF]-(ep:Class)&lt;-[ar:part_of]-(anoni:Individual)-[:INSTANCEOF]->(primary) WITH CASE WHEN ep IS NULL THEN [] ELSE COLLECT({ short_form: ep.short_form, label: coalesce(ep.label,''), iri: ep.iri, types: labels(ep), unique_facets: apoc.coll.sort(coalesce(ep.uniqueFacets, [])), symbol: coalesce(([]+ep.symbol)[0], '')} ) END AS targeting_splits,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn,def_pubs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Neuron Class' AS query, '89ca20c' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs, targeting_splits&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Class {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.1 //@libraries.3/@types.2"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for Split Class"
          description="Get JSON for Split Class"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Class) WHERE primary.short_form in [$id] WITH primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn OPTIONAL MATCH (:Class { label: 'intersectional expression pattern'})&lt;-[:SUBCLASSOF]-(primary)&lt;-[ar:part_of]-(anoni:Individual)-[:INSTANCEOF]->(n:Neuron) WITH CASE WHEN n IS NULL THEN [] ELSE COLLECT({ short_form: n.short_form, label: coalesce(n.label,''), iri: n.iri, types: labels(n), unique_facets: apoc.coll.sort(coalesce(n.uniqueFacets, [])), symbol: coalesce(([]+n.symbol)[0], '')} ) END AS target_neurons,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn,def_pubs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Split Class' AS query, '89ca20c' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs, target_neurons&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Class {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.1 //@libraries.3/@types.37"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for Individual"
          description="Get JSON for Individual:Anatomy"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Individual) WHERE primary.short_form in [$id] WITH primary OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license|license]->(l:License) WITH COLLECT ({ dataset: { link : coalesce(([]+ds.dataset_link)[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} }, license: { icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }}) AS dataset_license,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary,dataset_license OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) END AS self_xref, primary, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) + self_xref END AS xrefs,primary,dataset_license,parents,relationships OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, dataset_license, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }}) END AS channel_image,primary,dataset_license,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,dataset_license,parents,relationships,xrefs,channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,dataset_license,parents,relationships,xrefs,channel_image,pub_syn RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Individual' AS query, '89ca20c' AS version , dataset_license, parents, relationships, xrefs, channel_image, pub_syn, def_pubs&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Individual {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.0"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for Cluster"
          description="Get JSON for Cluster"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Cluster) WHERE primary.short_form in [$id] WITH primary OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license|license]->(l:License) WITH COLLECT ({ dataset: { link : coalesce(ds.dataset_link[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(ds.symbol[0], '')} }, license: { icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(l.symbol[0], '')} }}) AS dataset_license,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(o.symbol[0], '')} ) END AS parents ,primary,dataset_license OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(o.symbol[0], '')} }) END AS relationships ,primary,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(s.symbol[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix[0], '')}) END AS self_xref, primary, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(s.symbol[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix[0], '')}) + self_xref END AS xrefs,primary,dataset_license,parents,relationships OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, dataset_license, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(channel.symbol[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(technique.symbol[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(template.symbol[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(template_anat.symbol[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary,dataset_license,parents,relationships,xrefs OPTIONAL MATCH (o:Individual)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.uri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(o.symbol[0], ''), types: labels(o) }  }) END AS related_individuals ,primary,dataset_license,parents,relationships,xrefs,channel_image RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary) , unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(primary.symbol[0], '')}, description: coalesce(primary.description, []), comment : coalesce(primary.comment, primary.`annotation-comment`, []) } AS term, 'Get JSON for Cluster using modified Individual:Anatomy' AS query, 'ca9ab19' AS version , dataset_license, parents, relationships, xrefs, channel_image, related_individuals&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Cluster {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.22"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for Template"
          description="Get JSON for Template"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Template) WHERE primary.short_form in [$id] WITH primary MATCH (channel:Individual)&lt;-[irw:in_register_with]-(channel:Individual)-[:depicts]->(primary) WITH { index: coalesce(apoc.convert.toInteger(irw.index), []) + [], extent: ([]+irw.extent)[0], center: ([]+irw.center)[0], voxel: ([]+irw.voxel)[0], orientation: coalesce(([]+irw.orientation)[0], ''), image_folder: coalesce(([]+irw.folder)[0],''), channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} } as template_channel,primary OPTIONAL MATCH (technique:Class)&lt;-[:is_specified_output_of]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(primary) WHERE technique.short_form IN ['FBbi_00000224','FBbi_00000251'] AND exists(irw.index) WITH primary, template_channel, collect ({ channel: channel, irw: irw}) AS painted_domains UNWIND painted_domains AS pd OPTIONAL MATCH (channel:Individual { short_form: pd.channel.short_form})-[:depicts]-(ai:Individual)-[:INSTANCEOF]->(c:Class) WITH collect({ anatomical_type: { short_form: c.short_form, label: coalesce(c.label,''), iri: c.iri, types: labels(c), unique_facets: apoc.coll.sort(coalesce(c.uniqueFacets, [])), symbol: coalesce(([]+c.symbol)[0], '')} , anatomical_individual: { short_form: ai.short_form, label: coalesce(ai.label,''), iri: ai.iri, types: labels(ai), unique_facets: apoc.coll.sort(coalesce(ai.uniqueFacets, [])), symbol: coalesce(([]+ai.symbol)[0], '')} , folder: ([]+pd.irw.folder)[0], center: coalesce (pd.irw.center, []), index: [] + coalesce (pd.irw.index, []) }) AS template_domains,primary,template_channel OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license|license]->(l:License) WITH COLLECT ({ dataset: { link : coalesce(([]+ds.dataset_link)[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} }, license: { icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }}) AS dataset_license,primary,template_channel,template_domains OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary,template_channel,template_domains,dataset_license OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,template_channel,template_domains,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) END AS self_xref, primary, template_channel, template_domains, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) + self_xref END AS xrefs,primary,template_channel,template_domains,dataset_license,parents,relationships OPTIONAL MATCH (o:Individual)&lt;-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS related_individuals ,primary,template_channel,template_domains,dataset_license,parents,relationships,xrefs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Template' AS query, '89ca20c' AS version , template_channel, template_domains, dataset_license, parents, relationships, xrefs, related_individuals&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:Template {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.20"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for pub"
          description="Fetches JSON for pub."
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:Individual:pub) WHERE primary.short_form in [$id] WITH primary OPTIONAL MATCH (primary)-[:has_reference]-(ds:DataSet)-[:has_license|license]->(l:License) WITH COLLECT ({ dataset: { link : coalesce(([]+ds.dataset_link)[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} }, license: { icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }}) AS dataset_license,primary RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for pub' AS query, '89ca20c' AS version , dataset_license, {title: coalesce(([]+primary.title)[0], '') ,PubMed: coalesce(([]+primary.PMID)[0], ''), FlyBase: coalesce(([]+primary.FlyBase)[0], ''), DOI: coalesce(([]+primary.DOI)[0], '') }AS pub_specific_content&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:pub:Individual {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.16"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for DataSet"
          description="Get JSON for DataSet"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:DataSet) WHERE primary.short_form in [$id] WITH primary CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) END AS self_xref, primary, anatomy_channel_image OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(([]+s.homepage)[0], ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(([]+s.link_icon_url)[0], ''), link_postfix: coalesce(([]+s.link_postfix)[0], '')}) + self_xref END AS xrefs,primary,anatomy_channel_image OPTIONAL MATCH (primary)-[:has_license|license]->(l:License) WITH collect ({ icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }) as license,primary,anatomy_channel_image,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS pubs,primary,anatomy_channel_image,xrefs,license OPTIONAL MATCH (primary)&lt;-[:has_source]-(i:Individual) WITH i, primary, anatomy_channel_image, xrefs, license, pubs OPTIONAL MATCH (i)-[:INSTANCEOF]-(c:Class) WITH DISTINCT { images: count(distinct i),types: count(distinct c) } as dataset_counts,primary,anatomy_channel_image,xrefs,license,pubs RETURN { link : coalesce(([]+primary.dataset_link)[0], ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for DataSet' AS query, '89ca20c' AS version , anatomy_channel_image, xrefs, license, pubs, dataset_counts&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:DataSet {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.24"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get JSON for License"
          description="Get JSON for License"
          runForCount="false"
          query="&quot;statement&quot;: &quot;MATCH (primary:License) WHERE primary.short_form in [$id] WITH primary RETURN { icon : coalesce(([]+primary.license_logo)[0], ''), link : coalesce(([]+primary.license_url)[0], ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for License' AS query, '89ca20c' AS version &quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }"
          countQuery="&quot;statement&quot;: &quot;MATCH (primary:License {short_form: $id} ) RETURN count(primary) as count&quot;, &quot;parameters&quot; : { &quot;id&quot; : &quot;$ID&quot; }">
        <matchingCriteria
            type="//@libraries.3/@types.30"/>
      </queryChain>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Term JSON"
          description="Process Term JSON"
          runForCount="false"
          queryProcessorId="vfbProcessTermInfoJson"/>
    </fetchVariableQuery>
  </dataSources>
  <dataSources
      id="aberOWLDataSource"
      name="Aber OWL Data Source"
      dataSourceService="aberOWLDataSource"
      url="http://owl.virtualflybrain.org/api/runQuery.groovy"
      dependenciesLibrary="//@libraries.3"
      targetLibrary="//@libraries.4"/>
  <dataSources
      id="owleryDataSourceSubclass"
      name="owlery Data Source (subclasses)"
      dataSourceService="owleryDataSource"
      url="http://owl.virtualflybrain.org/kbs/vfb/subclasses"
      dependenciesLibrary="//@libraries.3"
      targetLibrary="//@libraries.4">
    <queries
        xsi:type="gep_2:SimpleQuery"
        name="Owlery Part of"
        description="Part of $NAME"
        query="object=%3Chttp://purl.obolibrary.org/obo/BFO_0000050%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        name="Owlery Neuron class with part here"
        description="Neurons with some part here"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00005106%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002131%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        name="Owlery Neurons Synaptic"
        description="Neurons with synaptic terminals here"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00005106%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002130%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        name="Owlery Neurons Presynaptic"
        description="Neurons with presynaptic terminals here"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00005106%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002113%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        name="Owlery Neurons Postsynaptic"
        description="Neurons with postsynaptic terminals here"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00005106%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002110%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassIdListOnly"
        name="Owlery Pass id list only"
        description="Keep nothing slimply pass ids"
        queryProcessorId="owleryIdOnlyQueryProcessor"/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="AberNeuronClassesFasciculatingHere"
        name="Owlery Neuron classes fasciculating here"
        description="Neuron classes fasciculating here"
        returnType="//@libraries.3/@types.1"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00005106%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002101%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="innervatesX"
        name="Owlery tracts in"
        description="tracts in"
        returnType="//@libraries.3/@types.1"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00005099%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002134%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="subclasses"
        name="Owlery Subclasses of"
        description="Subclasses of $NAME"
        returnType="//@libraries.3/@types.1"
        query="object=%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="TransgenesExpressedInX "
        name="Owlery Transgenes expressed in "
        description="Transgenes expressed in "
        returnType="//@libraries.3/@types.1"
        query=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="lineageClones"
        name="Owlery Lineage Clones"
        description="Lineage clones found in"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00007683%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002131%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false&amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="CellThatOverlapsX"
        name="subClassOf cell that overlaps some X"
        description="subClassOf cell that overlaps some X"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00007002%3E%20and%20(%20%3Chttp://purl.obolibrary.org/obo/RO_0002131%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E%20)&amp;amp;direct=false&amp;amp;includeDeprecated=false&amp;amp;includeEquivalent=true"
        countQuery=""/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassIdListOnly"
        name="Owlery Pass 2nd id list only"
        description="Keep nothing slimply pass ids to 2nd list"
        queryProcessorId="owleryIdOnlyQueryProcessor2"/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassIdListOnly"
        name="Owlery Pass 3rd id list only"
        description="Keep nothing slimply pass ids to 3rd list"
        queryProcessorId="owleryIdOnlyQueryProcessor2"/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassIdListOnly"
        name="Owlery Pass 1st id list only"
        description="Keep nothing slimply pass ids to 1st list"
        queryProcessorId="owleryIdOnlyQueryProcessor2"/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="OverlapsX"
        name="subClassOf overlaps some X"
        description="subClassOf overlaps some X"
        query="object=%3Chttp://purl.obolibrary.org/obo/RO_0002131%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;amp;direct=false&amp;amp;includeDeprecated=false&amp;amp;includeEquivalent=false"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="CellOverlapsX"
        name="subClassOf cell overlaps some X"
        description="subClassOf cell overlaps some X"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00007002%3E%20%20that%20%3Chttp://purl.obolibrary.org/obo/RO_0002131%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;amp;direct=false&amp;amp;includeDeprecated=false&amp;amp;includeEquivalent=false"
        countQuery=""/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassIdListPlusQueryTerm"
        name="Owlery Pass Plus Query ID"
        description="Keep nothing slimply pass ids with query term"
        queryProcessorId="owleryIdOnlyQueryProcessorWithQueryTerm"/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassSolrIdListOnly"
        name="Owlery Class Pass solr id list only"
        description="Keep nothing slimply pass solr ids"
        queryProcessorId="owleryToSolrIdOnlyQueryProcessor"/>
  </dataSources>
  <dataSources
      id="owleryDataSourceRealise"
      name="owlery Data Source (instances)"
      dataSourceService="owleryDataSource"
      url="http://owl.virtualflybrain.org/kbs/vfb/instances"
      dependenciesLibrary="//@libraries.3"
      targetLibrary="//@libraries.4">
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="ImagesOfNeuronsWithSomePartHereClustered"
        name="Owlery Images of neurons with some part here (clustered)"
        description="Images of neurons with some part here (clustered)"
        returnType="//@libraries.3/@types.22"
        query="object=%3Chttp://purl.obolibrary.org/obo/C888C3DB-AEFA-447F-BD4C-858DFE33DBE7%3E%20some%20(%3Chttp://purl.obolibrary.org/obo/FBbt_00005106%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002131%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E)&amp;direct=false&amp;includeDeprecated=false"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="ImagesOfNeuronsWithSomePartHere"
        name="Owlery Images of neurons with some part here"
        description="Images of neurons with some part here"
        returnType="//@libraries.3/@types.2"
        query="object=%3Chttp://purl.obolibrary.org/obo/FBbt_00005106%3E%20and%20%3Chttp://purl.obolibrary.org/obo/RO_0002131%3E%20some%20%3Chttp://purl.obolibrary.org/obo/$ID%3E&amp;direct=false&amp;includeDeprecated=false"
        countQuery=""/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="Owlery_individual_parts"
        name="Owlery individual parts"
        description="Find individuals that are part of some X (useful for finding expression pattern parts)."
        returnType="//@libraries.3/@types.0"
        query="object=%3Chttp://purl.obolibrary.org/obo/BFO_0000050%3E%20some%20%3Chttp://virtualflybrain.org/reports/$ID%3E&amp;direct=false&amp;includeDeprecated=false"
        countQuery=""/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassIdListOnlyInstances"
        name="Owlery Pass id list only Instances"
        description="Keep nothing slimply pass ids"
        returnType="//@libraries.3/@types.0"
        queryProcessorId="owleryIdOnlyQueryProcessor"/>
    <queries
        xsi:type="gep_2:ProcessQuery"
        id="owlPassSolrIdListOnly"
        name="Owlery Ind Pass solr id list only"
        description="Keep nothing slimply pass solr ids"
        queryProcessorId="owleryToSolrIdOnlyQueryProcessor"/>
  </dataSources>
  <dataSources
      id="querycache"
      name="SOLR Cached Queries"
      dataSourceService="solrqueryDataSource"
      url="https://solr.VirtualFlyBrain.org/solr/vfb_json/select"
      dependenciesLibrary="//@libraries.3"
      targetLibrary="//@libraries.4">
    <libraryConfigurations
        library="//@libraries.0"
        modelInterpreterId="swcModelInterpreterService"
        format="swc"/>
    <libraryConfigurations
        library="//@libraries.1"
        modelInterpreterId="objModelInterpreterService"
        format="obj"/>
    <libraryConfigurations
        library="//@libraries.2"
        modelInterpreterId="owlModelInterpreterService"
        format="owl"/>
    <queries
        xsi:type="gep_2:SimpleQuery"
        id="cachedvfbjsoncall"
        name="Get cached VFB_JSON for Term"
        description="Get cached VFB_JSON for Term"
        query="&quot;params&quot;:{&quot;defType&quot;:&quot;edismax&quot;,&quot;fl&quot;:&quot;term_info&quot;,&quot;indent&quot;:&quot;true&quot;,&quot;q.op&quot;:&quot;OR&quot;,&quot;q&quot;:&quot;$ID&quot;,&quot;qf&quot;:&quot;id&quot;,&quot;rows&quot;:&quot;1&quot;}"
        countQuery="&quot;params&quot;:{&quot;defType&quot;:&quot;edismax&quot;,&quot;fl&quot;:&quot;term_info&quot;,&quot;indent&quot;:&quot;true&quot;,&quot;q.op&quot;:&quot;OR&quot;,&quot;q&quot;:&quot;$ID&quot;,&quot;qf&quot;:&quot;id&quot;,&quot;rows&quot;:&quot;1&quot;}"/>
    <queries
        xsi:type="gep_2:CompoundQuery"
        name="Get and process example images from SOLR from id list"
        description=""
        runForCount="false">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get anat_query"
          description="Fetches essential details."
          query="&quot;params&quot;:{&quot;defType&quot;:&quot;edismax&quot;,&quot;fl&quot;:&quot;anat_query,anat_image_query&quot;,&quot;indent&quot;:&quot;true&quot;,&quot;q.op&quot;:&quot;OR&quot;,&quot;q&quot;:&quot;id:*&quot;,&quot;fq&quot;:&quot;{!terms f=id}$ARRAY_ID_RESULTS&quot;}"
          countQuery="&quot;params&quot;:{&quot;defType&quot;:&quot;edismax&quot;,&quot;fl&quot;:&quot;anat_query,anat_image_query&quot;,&quot;indent&quot;:&quot;true&quot;,&quot;q.op&quot;:&quot;OR&quot;,&quot;q&quot;:&quot;id:*&quot;,&quot;fq&quot;:&quot;{!terms f=id}$ARRAY_ID_RESULTS&quot;}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process images"
          queryProcessorId="solrQueryProcessor"/>
    </queries>
    <fetchVariableQuery
        xsi:type="gep_2:CompoundQuery"
        name="Process Cached JSON"
        description="">
      <queryChain
          xsi:type="gep_2:SimpleQuery"
          name="Get term info"
          description="Fetches essential details."
          query="&quot;params&quot;:{&quot;defType&quot;:&quot;edismax&quot;,&quot;fl&quot;:&quot;term_info&quot;,&quot;indent&quot;:&quot;true&quot;,&quot;q.op&quot;:&quot;OR&quot;,&quot;q&quot;:&quot;id:$ID&quot;,&quot;qf&quot;:&quot;id&quot;,&quot;rows&quot;:&quot;1&quot;}"
          countQuery="&quot;params&quot;:{&quot;defType&quot;:&quot;edismax&quot;,&quot;fl&quot;:&quot;term_info&quot;,&quot;indent&quot;:&quot;true&quot;,&quot;q.op&quot;:&quot;OR&quot;,&quot;q&quot;:&quot;id:$ID&quot;,&quot;qf&quot;:&quot;id&quot;,&quot;rows&quot;:&quot;1&quot;}"/>
      <queryChain
          xsi:type="gep_2:ProcessQuery"
          name="Process Cached JSON"
          description="Process Cached JSON"
          queryProcessorId="vfbProcessTermInfoCachedJson"/>
    </fetchVariableQuery>
  </dataSources>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="ListAllAvailableImages"
      name="List all available images for class with examples"
      description="List all available images of $NAME"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.3">
    <matchingCriteria
        type="//@libraries.3/@types.21 //@libraries.3/@types.1"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="TransgeneExpressionHere"
      name="Expression overlapping selected anatomy"
      description="Reports of transgene expression in $NAME"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.2/@queries.8 //@dataSources.2/@queries.14 //@dataSources.0/@queries.8 //@dataSources.2/@queries.16 //@dataSources.2/@queries.12 //@dataSources.0/@queries.11 //@dataSources.2/@queries.0 //@dataSources.2/@queries.13 //@dataSources.0/@queries.14">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.28 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.28 //@libraries.3/@types.2"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="ExpressionOverlapsHere"
      name="Expression overlapping what anatomy"
      description="Anatomy $NAME is expressed in"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.0/@queries.10">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.27"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.46"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="NeuronClassesFasciculatingHere"
      name="Neuron classes fasciculating here"
      description="Neurons fasciculating in $NAME"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.2/@queries.6 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.3"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="ImagesNeurons"
      name="Images of neurons with some part here"
      description="Images of neurons with some part in $NAME"
      returnType="//@libraries.3/@types.2"
      queryChain="//@dataSources.3/@queries.1 //@dataSources.3/@queries.4 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.23"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="NeuronsPartHere"
      name="Neurons with any part here"
      description="Neurons with some part in $NAME"
      queryChain="//@dataSources.2/@queries.1 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.26"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.23"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="epFrag"
      name="Images of expression pattern fragments"
      description="Images of fragments of $NAME"
      queryChain="//@dataSources.3/@queries.2 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.27"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="NeuronsSynaptic"
      name="Neurons Synaptic"
      description="Neurons with synaptic terminals in $NAME"
      queryChain="//@dataSources.2/@queries.2 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.26"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.23"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="NeuronsPresynapticHere"
      name="Neurons Presynaptic"
      description="Neurons with presynaptic terminals in $NAME"
      queryChain="//@dataSources.2/@queries.3 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.26"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.23"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="NeuronsPostsynapticHere"
      name="Neurons Postsynaptic"
      description="Neurons with postsynaptic terminals in $NAME"
      queryChain="//@dataSources.2/@queries.4 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.26"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.23"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="PaintedDomains"
      name="Show all painted domains for template"
      description="List all painted anatomy available for $NAME"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.4">
    <matchingCriteria
        type="//@libraries.3/@types.20 //@libraries.3/@types.0"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="DatasetImages"
      name="Show all images for a dataset"
      description="List all images included in $NAME"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.6">
    <matchingCriteria
        type="//@libraries.3/@types.24 //@libraries.3/@types.41"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="TractsNervesInnervatingHere"
      name="Tracts/nerves innervating synaptic neuropil"
      description="Tracts/nerves innervating $NAME"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.2/@queries.7 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.23"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="ComponentsOf"
      name="Components of"
      description="Components of $NAME"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.2/@queries.0 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.4"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="LineageClonesIn"
      name="Lineage clones found here"
      description="Lineage clones found in $NAME"
      returnType="//@libraries.3/@types.4"
      queryChain="//@dataSources.2/@queries.10 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.5"/>
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.23"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="AllAlignedImages"
      name="Show all images aligned to template"
      description="List all images aligned to $NAME"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.7">
    <matchingCriteria
        type="//@libraries.3/@types.20 //@libraries.3/@types.0"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="PartsOf"
      name="Parts of"
      description="Parts of $NAME"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.2/@queries.0 //@dataSources.2/@queries.18 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="SubclassesOf"
      name="Subclasses of"
      description="Subclasses of $NAME"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.2/@queries.8 //@dataSources.2/@queries.5 //@dataSources.4/@queries.1">
    <matchingCriteria
        type="//@libraries.3/@types.1"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="AlignedDatasets"
      name="Show all datasets aligned to template"
      description="List all datasets aligned to $NAME"
      returnType="//@libraries.3/@types.24"
      queryChain="//@dataSources.0/@queries.12">
    <matchingCriteria
        type="//@libraries.3/@types.20 //@libraries.3/@types.0"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="AllDatasets"
      name="Show all datasets"
      description="List all datasets"
      returnType="//@libraries.3/@types.24"
      queryChain="//@dataSources.0/@queries.13">
    <matchingCriteria
        type="//@libraries.3/@types.20"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="ref_neuron_region_connectivity_query"
      name="Show connectivity to regions from Neuron X"
      description="Show connectivity per region for $NAME"
      queryChain="//@dataSources.0/@queries.15">
    <matchingCriteria
        type="//@libraries.3/@types.43"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="ref_neuron_neuron_connectivity_query"
      name="Show connectivity to neurons from Neuron X"
      description="Show neurons connected to $NAME"
      queryChain="//@dataSources.0/@queries.16">
    <matchingCriteria
        type="//@libraries.3/@types.42"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="SimilarMorphologyTo"
      name="has_similar_morphology_to"
      description="Neurons with similar morphology to $NAME  [NBLAST mean score]"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.17">
    <matchingCriteria
        type="//@libraries.3/@types.0 //@libraries.3/@types.2 //@libraries.3/@types.25"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="SimilarMorphologyToPartOf"
      name="has_similar_morphology_to_part_of_neuron"
      description="Expression patterns with some similar morphology to $NAME  [NBLAST mean score]"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.19">
    <matchingCriteria
        type="//@libraries.3/@types.0 //@libraries.3/@types.2 //@libraries.3/@types.44"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="TermsForPub"
      name="has_reference_to_pub"
      description="List all terms that reference $NAME"
      returnType="//@libraries.3/@types.36"
      queryChain="//@dataSources.0/@queries.18">
    <matchingCriteria
        type="//@libraries.3/@types.0 //@libraries.3/@types.16"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="SimilarMorphologyToPartOfexp"
      name="has_similar_morphology_to_part_of_exp"
      description="Neurons with similar morphology to part of $NAME  [NBLAST mean score]"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.19">
    <matchingCriteria
        type="//@libraries.3/@types.0 //@libraries.3/@types.27 //@libraries.3/@types.44"/>
    <matchingCriteria
        type="//@libraries.3/@types.0 //@libraries.3/@types.46 //@libraries.3/@types.44"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="SimilarMorphologyToNB"
      name="has_similar_morphology_to_nb"
      description="Neurons that overlap with $NAME  [NeuronBridge]"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.20">
    <matchingCriteria
        type="//@libraries.3/@types.45 //@libraries.3/@types.0 //@libraries.3/@types.27"/>
    <matchingCriteria
        type="//@libraries.3/@types.0 //@libraries.3/@types.45 //@libraries.3/@types.46"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="SimilarMorphologyToNBexp"
      name="has_similar_morphology_to_nb_exp"
      description="Expression patterns that overlap with $NAME  [NeuronBridge]"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.20">
    <matchingCriteria
        type="//@libraries.3/@types.45 //@libraries.3/@types.0 //@libraries.3/@types.2"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="anatScRNAseqQuery"
      name="anat_scRNAseq_query"
      description="Single cell transcriptomics data for $NAME"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.2/@queries.8 //@dataSources.2/@queries.17 //@dataSources.0/@queries.22">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.28 //@libraries.3/@types.47"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="clusterExpression"
      name="cluster_expression"
      description="Genes expressed in $NAME"
      returnType="//@libraries.3/@types.1"
      queryChain="//@dataSources.0/@queries.21">
    <matchingCriteria
        type="//@libraries.3/@types.0 //@libraries.3/@types.22"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="scRNAdatasetData"
      name="Show all data for a scRNAseq dataset"
      description="List all data for $NAME"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.23">
    <matchingCriteria
        type="//@libraries.3/@types.24 //@libraries.3/@types.47"/>
  </queries>
  <queries xsi:type="gep_2:CompoundRefQuery"
      id="expressionCluster"
      name="expression_cluster"
      description="scRNAseq clusters expressing $NAME"
      returnType="//@libraries.3/@types.0"
      queryChain="//@dataSources.0/@queries.24">
    <matchingCriteria
        type="//@libraries.3/@types.1 //@libraries.3/@types.48 //@libraries.3/@types.47"/>
  </queries>
</gep:GeppettoModel>
